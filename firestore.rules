rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to get user role
    function getUserRole() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid))
             ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role
             : null;
    }

    // Helper function to check if user is inspecteur
    function isInspecteur() {
      return getUserRole() == 'inspecteur';
    }

    // Helper function to check if user is manager
    function isManager() {
      return getUserRole() == 'manager';
    }

    // Helper function to check if user is technicien
    function isTechnicien() {
      return getUserRole() == 'technicien';
    }

    // Helper function to check if status transition is valid for role
    function isValidStatusTransition(oldStatus, newStatus, userRole) {
      // If status is not changing, allow it
      return oldStatus == newStatus ||
        // Manager can change "Ouvert" -> "En cours"
        (userRole == 'manager' &&
         (oldStatus == 'Ouvert' || oldStatus == 'ouvert') &&
         (newStatus == 'En cours' || newStatus == 'en cours')) ||
        // Technicien can change "En cours" -> "Résolu"
        (userRole == 'technicien' &&
         (oldStatus == 'En cours' || oldStatus == 'en cours') &&
         (newStatus == 'Résolu' || newStatus == 'résolu' || newStatus == 'Resolu'));
    }

    // Helper function to check if user is the owner of a document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to validate anomaly data structure
    function isValidAnomaly(data) {
      return data.keys().hasAll(['title', 'description', 'date', 'location', 'category', 'priority', 'status', 'createdBy', 'createdAt']) &&
             data.title is string &&
             data.description is string &&
             data.location is string &&
             data.category is string &&
             data.priority is string &&
             data.status is string &&
             data.createdBy is string &&
             data.date is timestamp &&
             data.createdAt is timestamp;
    }

    // Helper function to validate comment data structure
    function isValidComment(data) {
      return data.keys().hasAll(['anomalyId', 'text', 'createdBy', 'createdAt']) &&
             data.anomalyId is string &&
             data.text is string &&
             data.createdBy is string &&
             data.createdAt is timestamp &&
             // imageUrl is optional
             (!('imageUrl' in data) || data.imageUrl is string);
    }

    // Helper function to validate notification data structure
    function isValidNotification(data) {
      return data.keys().hasAll(['title', 'description', 'type', 'date', 'isRead', 'userId']) &&
             data.title is string &&
             data.description is string &&
             data.type is string &&
             data.date is timestamp &&
             data.isRead is bool &&
             data.userId is string;
    }

    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Read: User can read their own profile, manager and technicien can read all
      allow read: if isAuthenticated() && (isOwner(userId) || isManager() || isTechnicien());
      
      // Create: Only during registration (user creating their own document)
      allow create: if isAuthenticated() &&
                       isOwner(userId) &&
                       request.resource.data.keys().hasAll(['name', 'email', 'role']) &&
                       request.resource.data.name is string &&
                       request.resource.data.email is string &&
                       request.resource.data.role is string &&
                       request.resource.data.role in ['inspecteur', 'manager', 'technicien'];

      // Update: User can update their own profile (except role)
      allow update: if isAuthenticated() &&
                       isOwner(userId) &&
                       (!('role' in request.resource.data.diff(resource.data).affectedKeys()) ||
                        request.resource.data.role == resource.data.role);

      // Delete: Users cannot delete their own accounts (for safety)
      allow delete: if false;
    }

    // ============================================
    // ANOMALIES COLLECTION
    // ============================================
    match /anomalies/{anomalyId} {
      // Read: All authenticated users can read all anomalies
      allow read: if isAuthenticated();

      // Create: All authenticated users can create anomalies
      allow create: if isAuthenticated() &&
                       isValidAnomaly(request.resource.data) &&
                       request.resource.data.createdBy is string &&
                       request.resource.data.createdBy.size() > 0;

      // Update:
      // - Manager can change status from "ouvert" to "en cours"
      // - Technicien can change status from "en cours" to "resolu"
      // - Creator can update their own anomaly (except status changes that require specific roles)
      // - Cannot change createdBy or createdAt
      allow update: if isAuthenticated() && (
        // Prevent changing createdBy or createdAt
        !('createdBy' in request.resource.data.diff(resource.data).affectedKeys()) &&
        !('createdAt' in request.resource.data.diff(resource.data).affectedKeys())
      ) && (
        // If status is being changed, check role-based permissions
        !('status' in request.resource.data.diff(resource.data).affectedKeys()) ||
        isValidStatusTransition(
          resource.data.status,
          request.resource.data.status,
          getUserRole()
        ) ||
        // Creator can update other fields (not status) of their own anomaly
        (isOwner(resource.data.createdBy) &&
         !('status' in request.resource.data.diff(resource.data).affectedKeys()))
      );

      // Delete: Users cannot delete anomalies (for data integrity)
      allow delete: if false;

      // Allow queries on anomalies collection
      allow list: if isAuthenticated();
    }

    // ============================================
    // COMMENTS COLLECTION
    // ============================================
    match /comments/{commentId} {
      // Read: All authenticated users can read comments
      allow read: if isAuthenticated();

      // Create: All authenticated users can create comments
      allow create: if isAuthenticated() &&
                       isValidComment(request.resource.data) &&
                       request.resource.data.createdBy is string &&
                       request.resource.data.createdBy.size() > 0 &&
                       // Verify that the anomaly exists
                       exists(/databases/$(database)/documents/anomalies/$(request.resource.data.anomalyId));

      // Update: Only the creator can update their own comment
      // Note: The 1-minute edit window is enforced in the app, not in rules
      allow update: if isAuthenticated() &&
                       isOwner(resource.data.createdBy) &&
                       request.resource.data.keys().hasAll(['anomalyId', 'text', 'createdBy', 'createdAt']) &&
                       request.resource.data.anomalyId == resource.data.anomalyId &&
                       request.resource.data.createdBy == resource.data.createdBy &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.text is string;

      // Delete: Creator can delete comments
      allow delete: if isAuthenticated() &&
        isOwner(resource.data.createdBy);

      // Allow queries on comments collection
      allow list: if isAuthenticated();
    }

    // ============================================
    // NOTIFICATIONS COLLECTION
    // ============================================
    match /notifications/{notificationId} {
      // Read: User can read their own notifications, manager and technicien can read all
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isManager() ||
        isTechnicien()
      );

      // Create: Manager and technicien can create notifications for any user
      // Regular users (inspecteur) can only create notifications for themselves
      // Note: Ideally this should be done via Cloud Functions, but allowing here for app functionality
      allow create: if isAuthenticated() &&
                       isValidNotification(request.resource.data) &&
                       (isManager() ||
                        isTechnicien() ||
                        request.resource.data.userId == request.auth.uid);

      // Update: User can mark their own notifications as read
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']) &&
        request.resource.data.isRead == true
      );

      // Delete: User can delete their own notifications
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid
      );

      // Allow queries on notifications collection
      // Users can only query their own notifications (enforced by app querying with userId filter)
      // Manager and technicien can query all notifications
      allow list: if isAuthenticated() &&
                     (request.query.limit <= 50 || isManager() || isTechnicien());
    }

    // ============================================
    // DENY ALL OTHER ACCESS
    // ============================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

