rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // Helper function to check if user is superviseur
    function isSuperviseur() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superviseur' || 
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
    }
    
    // Helper function to check if user is the owner of a document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to validate anomaly data structure
    function isValidAnomaly(data) {
      return data.keys().hasAll(['title', 'description', 'date', 'location', 'category', 'priority', 'status', 'createdBy', 'createdAt']) &&
             data.title is string &&
             data.description is string &&
             data.location is string &&
             data.category is string &&
             data.priority is string &&
             data.status is string &&
             data.createdBy is string &&
             data.date is timestamp &&
             data.createdAt is timestamp;
    }
    
    // Helper function to validate comment data structure
    function isValidComment(data) {
      return data.keys().hasAll(['anomalyId', 'text', 'createdBy', 'createdAt']) &&
             data.anomalyId is string &&
             data.text is string &&
             data.createdBy is string &&
             data.createdAt is timestamp;
    }
    
    // Helper function to validate notification data structure
    function isValidNotification(data) {
      return data.keys().hasAll(['title', 'description', 'type', 'date', 'isRead', 'userId']) &&
             data.title is string &&
             data.description is string &&
             data.type is string &&
             data.date is timestamp &&
             data.isRead is bool &&
             data.userId is string;
    }
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Read: User can read their own profile, admin can read all
      allow read: if isAuthenticated() && (isOwner(userId) || isAdmin());
      
      // Create: Only during registration (user creating their own document)
      allow create: if isAuthenticated() && 
                       isOwner(userId) &&
                       request.resource.data.keys().hasAll(['name', 'email', 'role']) &&
                       request.resource.data.name is string &&
                       request.resource.data.email is string &&
                       request.resource.data.role is string &&
                       request.resource.data.role in ['inspecteur', 'superviseur', 'admin'];
      
      // Update: User can update their own profile (except role), admin can update anything
      allow update: if isAuthenticated() && (
        (isOwner(userId) && 
         (!('role' in request.resource.data.diff(resource.data).affectedKeys()) || 
          request.resource.data.role == resource.data.role)) ||
        isAdmin()
      );
      
      // Delete: Only admin can delete users
      allow delete: if isAdmin();
    }
    
    // ============================================
    // ANOMALIES COLLECTION
    // ============================================
    match /anomalies/{anomalyId} {
      // Read: All authenticated users can read all anomalies
      allow read: if isAuthenticated();
      
      // Create: All authenticated users can create anomalies
      // Note: We allow any string for createdBy to support cases where user document might not exist yet
      // or where email is used as fallback
      allow create: if isAuthenticated() &&
                       isValidAnomaly(request.resource.data) &&
                       request.resource.data.createdBy is string &&
                       request.resource.data.createdBy.size() > 0;
      
      // Update: 
      // - Creator can update their own anomaly
      // - Superviseur and Admin can update any anomaly (especially status)
      // - Cannot change createdBy or createdAt
      allow update: if isAuthenticated() && (
        // Allow if user is superviseur or admin
        isSuperviseur() ||
        // OR if user is the creator (check by name or email from user document)
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         (resource.data.createdBy == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.name ||
          resource.data.createdBy == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email))
      ) && (
        // Prevent changing createdBy or createdAt
        !('createdBy' in request.resource.data.diff(resource.data).affectedKeys()) &&
        !('createdAt' in request.resource.data.diff(resource.data).affectedKeys())
      );
      
      // Delete: Only admin can delete anomalies
      allow delete: if isAdmin();
      
      // Allow queries on anomalies collection
      allow list: if isAuthenticated();
    }
    
    // ============================================
    // COMMENTS COLLECTION
    // ============================================
    match /comments/{commentId} {
      // Read: All authenticated users can read comments
      allow read: if isAuthenticated();
      
      // Create: All authenticated users can create comments
      allow create: if isAuthenticated() &&
                       isValidComment(request.resource.data) &&
                       request.resource.data.createdBy is string &&
                       request.resource.data.createdBy.size() > 0 &&
                       // Verify that the anomaly exists
                       exists(/databases/$(database)/documents/anomalies/$(request.resource.data.anomalyId));
      
      // Update: Only the creator can update their own comment
      // Note: The 1-minute edit window is enforced in the app, not in rules
      allow update: if isAuthenticated() &&
                       // Check if user is the creator by comparing with user document (name or email)
                       (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                        (resource.data.createdBy == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.name ||
                         resource.data.createdBy == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email)) &&
                       request.resource.data.keys().hasAll(['anomalyId', 'text', 'createdBy', 'createdAt']) &&
                       request.resource.data.anomalyId == resource.data.anomalyId &&
                       request.resource.data.createdBy == resource.data.createdBy &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.text is string;
      
      // Delete: Creator or admin can delete comments
      allow delete: if isAuthenticated() && (
        isAdmin() ||
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         (resource.data.createdBy == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.name ||
          resource.data.createdBy == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email))
      );
      
      // Allow queries on comments collection
      allow list: if isAuthenticated();
    }
    
    // ============================================
    // NOTIFICATIONS COLLECTION
    // ============================================
    match /notifications/{notificationId} {
      // Read: User can read their own notifications, admin can read all
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Create: Admin and superviseur can create notifications for any user
      // Regular users can only create notifications for themselves
      // Note: Ideally this should be done via Cloud Functions, but allowing here for app functionality
      allow create: if isAuthenticated() &&
                       isValidNotification(request.resource.data) &&
                       (isSuperviseur() || 
                        request.resource.data.userId == request.auth.uid);
      
      // Update: User can mark their own notifications as read, admin can update any
      allow update: if isAuthenticated() && (
        (resource.data.userId == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']) &&
         request.resource.data.isRead == true) ||
        isAdmin()
      );
      
      // Delete: User can delete their own notifications, admin can delete any
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Allow queries on notifications collection
      // Users can only query their own notifications (enforced by app querying with userId filter)
      // Admin can query all notifications
      allow list: if isAuthenticated() && 
                     (request.query.limit <= 50 || isAdmin());
    }
    
    // ============================================
    // DENY ALL OTHER ACCESS
    // ============================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

